#+title: Get Programming With Haskell

*** chapter 17 Semigroups and Monoids

1.Monoid requires you to specify an identity element.

** Unit5 - Working with type in a context

1. Use Functor, when you have (a -> b) in context.
2. Use applicative, when you have (f a -> b) in context.
3. Use applicative, for Maybe (Int -> Double).
4. Use Monad, when (a -> f b) is in context.

*** chapter27 - The Functor typeclass 

1. Transform the types of values inside a Maybe 
2. Types of kind * -> * are parameterized types that take just one type parameter.
3. Member of Functor include List, Map, Maybe and IO.
4. [Int], Maybe Int, and IO Int can all use the same core functions.
5. Functor’s <$> provides a common interface to apply any function to a
value in a context.
6. Functor’s <$> provides a common interface to apply any function to a
value in a context.
7. fmap type signature
   #+begin_src haskell
   fmap :: Functor f => (a -> b) -> f a -> f b
   #+end_src

** chapter28 - A peek at the applicative typeclass

1. applicative type signature. <*> operator (pro-
nounced app)
#+begin_src haskell
(<*>) :: Applicative f => f (a -> b) -> f a -> f b
#+end_src
2. limitation of Functor's fmap is that it only works on single-argument functions.
3. Using Functor's <$> operator for partial application in a context
#+begin_src haskell
maybeInc = (+) <$> Just 1
#+end_src
4. 